<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Non-Parametric Joint Density Estimation • carbondate</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Non-Parametric Joint Density Estimation">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">carbondate</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.1.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/carbondate.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/Independent_calibration.html">Independent and Joint Radiocarbon Calibration</a></li>
    <li><a class="dropdown-item" href="../articles/Against_SPDs.html">Why Not to Use SPDs</a></li>
    <li><a class="dropdown-item" href="../articles/Non-parametric-summed-density.html">Non-Parametric Joint Density Estimation</a></li>
    <li><a class="dropdown-item" href="../articles/Poisson-process-modelling.html">Poisson Process Modelling</a></li>
    <li><a class="dropdown-item" href="../articles/determining-convergence.html">Determining Convergence</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/TJHeaton/carbondate/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Non-Parametric Joint Density Estimation</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/TJHeaton/carbondate/blob/main/vignettes/Non-parametric-summed-density.Rmd" class="external-link"><code>vignettes/Non-parametric-summed-density.Rmd</code></a></small>
      <div class="d-none name"><code>Non-parametric-summed-density.Rmd</code></div>
    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/TJHeaton/carbondate" class="external-link">carbondate</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<div class="section level2">
<h2 id="non-parametric-calibration-of-multiple-related-14c-samples">Non-parametric calibration of multiple related <sup>14</sup>C
samples<a class="anchor" aria-label="anchor" href="#non-parametric-calibration-of-multiple-related-14c-samples"></a>
</h2>
<div class="section level3">
<h3 id="model-details">Model details<a class="anchor" aria-label="anchor" href="#model-details"></a>
</h3>
<p>We model the underlying shared calendar age density
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>
as an infinite and unknown mixture of individual calendar age
<em>clusters/phases</em>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mtext mathvariant="normal">Cluster</mtext><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mtext mathvariant="normal">Cluster</mtext><mn>2</mn></msub><mo>+</mo><msub><mi>w</mi><mn>3</mn></msub><msub><mtext mathvariant="normal">Cluster</mtext><mn>3</mn></msub><mo>+</mo><mi>…</mi></mrow><annotation encoding="application/x-tex">
f(\theta) = w_1 \textrm{Cluster}_1 + w_2 \textrm{Cluster}_2 + w_3 \textrm{Cluster}_3 + \ldots 
</annotation></semantics></math> Each calendar age <em>cluster</em> in
the mixture has a normal distribution with a different location and
spread (i.e., an unknown mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\mu_j</annotation></semantics></math>
and precision
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>τ</mi><mi>j</mi><mn>2</mn></msubsup><annotation encoding="application/x-tex">\tau_j^2</annotation></semantics></math>).
Each object is then considered to have been drawn from one of the
(infinite) clusters that together constitute the overall
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>.</p>
<p>Such a model allows considerable flexibility in the estimation of the
joint calendar age density
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>
— not only allowing us to build simple mixtures but also approximate
more complex distributions (see illustration below). In some cases, this
mix of normal densities may represent true and distinct underlying
normal archaeological phases, in which case additional practical
inference may be possible. However this is not required for the method
to provide good estimation of a wide range of underlying
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>
distributions.</p>
<p>The probability that a particular sample is drawn from a particular
cluster will depend upon the relative weight
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>j</mi></msub><annotation encoding="application/x-tex">w_j</annotation></semantics></math>
given to that specific cluster. It will be more likely that an object
will come from some clusters than others. Given an object belongs to a
particular cluster, its prior calendar age will then be normally
distributed with the mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\mu_j</annotation></semantics></math>
and precision
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>τ</mi><mi>j</mi><mn>2</mn></msubsup><annotation encoding="application/x-tex">\tau_j^2</annotation></semantics></math>
of that cluster.</p>
<div class="figure">
<img src="Non-parametric-summed-density_files/figure-html/illustrate_mixture-1.png" alt="_An illustration of building up a potentially complex distribution $f(\theta)$ using mixtures of normals. Left Panel: A simple mixture of three (predominantly disjoint) normal clusters (blue dashed lines) results in an overall $f(\theta)$ that is tri-modal (solid red). Right Panel: Overlapping normal clusters (blue dashed lines) can however create more complex $f(\theta)$ distributions (solid red)._" width="100%"><p class="caption">
<em>An illustration of building up a potentially complex distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>
using mixtures of normals. Left Panel: A simple mixture of three
(predominantly disjoint) normal clusters (blue dashed lines) results in
an overall
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>
that is tri-modal (solid red). Right Panel: Overlapping normal clusters
(blue dashed lines) can however create more complex
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>
distributions (solid red).</em>
</p>
</div>
</div>
<div class="section level3">
<h3 id="estimation-of-the-shared-underlying-density">Estimation of the shared underlying density<a class="anchor" aria-label="anchor" href="#estimation-of-the-shared-underlying-density"></a>
</h3>
<p>To estimate the shared calendar age density
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>
based upon our set of <sup>14</sup>C observations,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">X_1, \ldots, X_N</annotation></semantics></math>,
we need to estimate:</p>
<ul>
<li>the mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\mu_j</annotation></semantics></math>
and precision
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>τ</mi><mi>j</mi><mn>2</mn></msubsup><annotation encoding="application/x-tex">\tau_j^2</annotation></semantics></math>
of each individual normal cluster within the overall mixture
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>,</li>
<li>the weighting
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>j</mi></msub><annotation encoding="application/x-tex">w_j</annotation></semantics></math>
associated to that cluster</li>
</ul>
<p>This requires us to also calibrate the <sup>14</sup>C determinations
to obtain their calendar ages
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>θ</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">\theta_1, \ldots, \theta_N</annotation></semantics></math>.
Since we assume that the calendar ages of each object arise from the
shared density, this must be performed simultaneously to the estimation
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>.</p>
<p>We use Markov Chain Monte Carlo (MCMC) to iterate, for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">k = 1, \ldots, M</annotation></semantics></math>,
between:</p>
<ul>
<li>Calibrate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">X_1, \ldots, X_n</annotation></semantics></math>
to obtain calendar age estimates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>θ</mi><mn>1</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>,</mo><mi>…</mi><msubsup><mi>θ</mi><mi>N</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">\theta_1^{k+1}, \ldots \theta_N^{k+1}</annotation></semantics></math>
given current shared estimate that each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mi>i</mi></msub><mo>∼</mo><msup><mover><mi>f</mi><mo accent="true">̂</mo></mover><mi>k</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\theta_i \sim \hat{f}^k(\theta)</annotation></semantics></math>
</li>
<li>Update estimate of shared calendar age density (to obtain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>f</mi><mo accent="true">̂</mo></mover><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{f}_{k+1}(\theta)</annotation></semantics></math>
given current set of calendar ages
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>θ</mi><mn>1</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>,</mo><mi>…</mi><msubsup><mi>θ</mi><mi>N</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">\theta_1^{k+1}, \ldots \theta_N^{k+1}</annotation></semantics></math>
</li>
</ul>
<p>After running the sampler for a large number of iterations (until we
are sufficiently confident that the MCMC has converged) we obtain
estimates for the calendar age
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\theta_i</annotation></semantics></math>
of each sample, and an estimate for the shared calendar age density
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>f</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{f}(\theta)</annotation></semantics></math>
from which they arose. These latter estimates of the shared calendar age
density are called <em>predictive estimates</em>, i.e., they provide
estimates of the calendar age of a hypothetical new sample (based on the
set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
samples that we have observed).</p>
<p>Critically, with our Bayesian non-parametric method, the number of
calendar age clusters that are represented in the observed data is
unknown (and is allowed to vary in each MCMC step). This flexibility is
different, and offers a substantial advantage, from other methods that
require the number of clusters to be known <em>a priori</em>. For full
technical details of the models used, and explanation of the model
parameters, see <span class="citation">Heaton (2022)</span>.</p>
</div>
<div class="section level3">
<h3 id="running-the-sampler">Running the sampler<a class="anchor" aria-label="anchor" href="#running-the-sampler"></a>
</h3>
<p>The MCMC updating is performed within an overall Gibbs MCMC scheme.
There are two different schemes provided to update the DPMM — a Polya
Urn approach <span class="citation">(Neal 2000)</span> which integrates
out the mixing weights of each cluster; and a slice sampling approach in
which they are explicitly retained <span class="citation">(Walker
2007)</span>.</p>
<p>Run using the Polya Urn method (our recommended approach based upon
testing):</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">polya_urn_output</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/PolyaUrnBivarDirichlet.html">PolyaUrnBivarDirichlet</a></span><span class="op">(</span></span>
<span>  rc_determinations <span class="op">=</span> <span class="va">kerr</span><span class="op">$</span><span class="va">c14_age</span>,</span>
<span>  rc_sigmas <span class="op">=</span> <span class="va">kerr</span><span class="op">$</span><span class="va">c14_sig</span>,</span>
<span>  calibration_curve <span class="op">=</span> <span class="va">intcal20</span>,</span>
<span>  n_iter <span class="op">=</span> <span class="fl">1e5</span>,</span>
<span>  n_thin <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<p>or the Walker method as follows:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">walker_output</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/WalkerBivarDirichlet.html">WalkerBivarDirichlet</a></span><span class="op">(</span></span>
<span>  rc_determinations <span class="op">=</span> <span class="va">kerr</span><span class="op">$</span><span class="va">c14_age</span>,</span>
<span>  rc_sigmas <span class="op">=</span> <span class="va">kerr</span><span class="op">$</span><span class="va">c14_sig</span>,</span>
<span>  calibration_curve <span class="op">=</span> <span class="va">intcal20</span>,</span>
<span>  n_iter <span class="op">=</span> <span class="fl">1e5</span>,</span>
<span>  n_thin <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<p><strong>Note:</strong> This example runs the MCMC for our default
choice of 100,000 iterations. However, as we discuss below, for this
challenging dataset we need a greater number of iterations to be
confident of convergence. We always suggest running the MCMC for at
least 100,000 iterations to arrive at the converged results. However,
for some complex datasets, longer runs may be required. More detail on
assessing convergence of the MCMC can be found in the <a href="determining-convergence.html">determining convergence
vignette</a></p>
<p>Both of these methods will output a list containing the sampler
outputs at every
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mtext mathvariant="normal">thin</mtext></msub><annotation encoding="application/x-tex">n_{\textrm{thin}}</annotation></semantics></math>
iteration, with the values of the model parameters and the calendar
ages.</p>
</div>
<div class="section level3">
<h3 id="post-processing">Post-processing<a class="anchor" aria-label="anchor" href="#post-processing"></a>
</h3>
<p>Our sampler provides three outputs of particular interest.</p>
<div class="section level5">
<h5 id="density-estimate-to-summarise-objects">Density Estimate to Summarise Objects<a class="anchor" aria-label="anchor" href="#density-estimate-to-summarise-objects"></a>
</h5>
<p>The output data contains information to allow calculation of the
predictive distribution for the calendar age of a new, as yet
undiscovered, object. This density estimate summarises the calendar ages
of all objects. It is generated using the posterior sampled values of
the DPMM component of our MCMC sampler. This calendar age density can be
calculated and plotted using
<code><a href="../reference/PlotPredictiveCalendarAgeDensity.html">PlotPredictiveCalendarAgeDensity()</a></code>. The pointwise mean of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>f</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{f}(\theta)</annotation></semantics></math>
will be plotted, together with a corresponding interval at (a
user-specified) probability level. If you assign the function to a
variable (as shown below) then the pointwise mean and corresponding
interval will also be stored and can be accessed.</p>
<p>The function allows calculation using multiple outputs so that their
results can be compared. For example below we compare the results from
the two sampler methods above.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">densities</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/PlotPredictiveCalendarAgeDensity.html">PlotPredictiveCalendarAgeDensity</a></span><span class="op">(</span></span>
<span>  output_data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">polya_urn_output</span>, <span class="va">walker_output</span><span class="op">)</span>,</span>
<span>  denscale <span class="op">=</span> <span class="fl">2.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="Non-parametric-summed-density_files/figure-html/plot_density-1.png" width="100%"></p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="co"># The mean (and default 2sigma intervals) are stored in densities</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">densities</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span> <span class="co"># The Polya Urn estimate</span></span>
<span><span class="co">#&gt;   calendar_age_BP density_mean density_ci_lower density_ci_upper</span></span>
<span><span class="co">#&gt; 1             471 2.388155e-06     6.820028e-08     1.662975e-05</span></span>
<span><span class="co">#&gt; 2             472 2.414024e-06     6.850713e-08     1.674722e-05</span></span>
<span><span class="co">#&gt; 3             473 2.440255e-06     6.975724e-08     1.684074e-05</span></span>
<span><span class="co">#&gt; 4             474 2.466856e-06     7.089821e-08     1.690925e-05</span></span>
<span><span class="co">#&gt; 5             475 2.493833e-06     7.155962e-08     1.700700e-05</span></span>
<span><span class="co">#&gt; 6             476 2.521193e-06     7.237446e-08     1.711630e-05</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">densities</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span> <span class="co"># The Walker estimate</span></span>
<span><span class="co">#&gt;   calendar_age_BP density_mean density_ci_lower density_ci_upper</span></span>
<span><span class="co">#&gt; 1             471 2.471499e-06     7.294953e-11     2.007406e-05</span></span>
<span><span class="co">#&gt; 2             472 2.488287e-06     7.431770e-11     2.007812e-05</span></span>
<span><span class="co">#&gt; 3             473 2.505414e-06     7.667058e-11     2.018940e-05</span></span>
<span><span class="co">#&gt; 4             474 2.522936e-06     7.858181e-11     2.051766e-05</span></span>
<span><span class="co">#&gt; 5             475 2.540896e-06     7.987301e-11     2.061738e-05</span></span>
<span><span class="co">#&gt; 6             476 2.559333e-06     8.491911e-11     2.079426e-05</span></span></code></pre></div>
<p>We also have the option to plot the SPD, to plot in the
F<sup>14</sup>C scale, and to change the confidence intervals on the
plot.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">densities</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/PlotPredictiveCalendarAgeDensity.html">PlotPredictiveCalendarAgeDensity</a></span><span class="op">(</span></span>
<span>  output_data <span class="op">=</span> <span class="va">polya_urn_output</span>,</span>
<span>  denscale <span class="op">=</span> <span class="fl">2.5</span>,</span>
<span>  show_SPD <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  interval_width <span class="op">=</span> <span class="st">"bespoke"</span>,</span>
<span>  bespoke_probability <span class="op">=</span> <span class="fl">0.8</span>,</span>
<span>  plot_14C_age <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p><img src="Non-parametric-summed-density_files/figure-html/plot_density_2-1.png" width="100%"></p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">densities</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt;   calendar_age_BP density_mean density_ci_lower density_ci_upper</span></span>
<span><span class="co">#&gt; 1             471 2.417808e-06     1.828800e-07     6.463847e-06</span></span>
<span><span class="co">#&gt; 2             472 2.443581e-06     1.850626e-07     6.550466e-06</span></span>
<span><span class="co">#&gt; 3             473 2.469702e-06     1.872705e-07     6.598948e-06</span></span>
<span><span class="co">#&gt; 4             474 2.496178e-06     1.889666e-07     6.693827e-06</span></span>
<span><span class="co">#&gt; 5             475 2.523014e-06     1.904662e-07     6.738775e-06</span></span>
<span><span class="co">#&gt; 6             476 2.550217e-06     1.924577e-07     6.853425e-06</span></span></code></pre></div>
<p><strong>Note:</strong> The fact that the two different MCMC samplers
do not provide matching probability intervals should flag to us that we
might not have reached convergence, and need to run the MCMC for longer.
Our investigations generally showed that
<code><a href="../reference/PolyaUrnBivarDirichlet.html">PolyaUrnBivarDirichlet()</a></code> is better at reaching convergence,
and so we recommend its use over <code><a href="../reference/WalkerBivarDirichlet.html">WalkerBivarDirichlet()</a></code>. A
longer run of 1,000,000 iterations indicates that the plotted Polya Urn
output (in green) above is an accurate representation of the predictive
distribution.</p>
<p>Around 1176 cal yr BP, we see a substantial change between the 95%
intervals for the summarised (predictive) estimate of the joint
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>
(which have a large spike) and the 80% intervals (which do not and are
smooth). This is not an error, but rather highlights a benefit of the
DPMM method whereby the number of clusters needed to represent the data
is allowed to vary. This feature occurs because the method is unsure if
the observed data support an additional (highly-concentrated) cluster
located around this time period. In some iterations of the MCMC, such a
cluster will be included; but for the majority of iterations, the method
believes it is not required. Since the plotted 80% interval does not
contain the spike, but the 95% does, it is likely that the method thinks
there is a 2.5–10% chance of such a distinct and highly-concentrated
cluster (as this is the proportion of the MCMC iterations containing
one). If more detailed inference is needed, one could look at the actual
individual MCMC iterations to estimate how likely such a
highly-concentrated cluster, resulting in a sudden spike in samples,
is.</p>
<p><em>Aside:</em> The sharp jump in the IntCal20 calibration curve at
1176 cal yr BP (774 cal AD) is due to an extreme solar particle event
(ESPE) also known as a Miyake Event <span class="citation">(Miyake et
al. 2012)</span>.</p>
</div>
<div class="section level5">
<h5 id="posterior-calendar-age-estimates-of-individual-samples">Posterior Calendar Age Estimates of Individual Samples<a class="anchor" aria-label="anchor" href="#posterior-calendar-age-estimates-of-individual-samples"></a>
</h5>
<p>The output data also includes the calendar age estimate for each
<sup>14</sup>C sample. We can use this to determine the posterior
distribution of the calendar age for each sample. Note that the calendar
age estimates use the joint information provided by all the
<sup>14</sup>C determinations (as opposed to solely the <sup>14</sup>C
determination of the single object that would be found using
<code><a href="../reference/CalibrateSingleDetermination.html">CalibrateSingleDetermination()</a></code>) on the understanding the
calendar ages of the objects are related.</p>
<p>You can calculate and plot this using
<code><a href="../reference/PlotCalendarAgeDensityIndividualSample.html">PlotCalendarAgeDensityIndividualSample()</a></code> - for example to
calculate the posterior calendar age distribution for the 21st
<sup>14</sup>C determination:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/PlotCalendarAgeDensityIndividualSample.html">PlotCalendarAgeDensityIndividualSample</a></span><span class="op">(</span><span class="fl">21</span>, <span class="va">polya_urn_output</span><span class="op">)</span></span></code></pre></div>
<p><img src="Non-parametric-summed-density_files/figure-html/plot_individual-1.png" width="100%"></p>
<p>The highest posterior density range for a given probability and the
unmodelled density (i.e., the result of
<code><a href="../reference/CalibrateSingleDetermination.html">CalibrateSingleDetermination()</a></code>) can also be shown on the
plot by specifying this in the arguments, as shown below.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/PlotCalendarAgeDensityIndividualSample.html">PlotCalendarAgeDensityIndividualSample</a></span><span class="op">(</span></span>
<span>  <span class="fl">21</span>, <span class="va">polya_urn_output</span>, show_hpd_ranges <span class="op">=</span> <span class="cn">TRUE</span>, show_unmodelled_density <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="Non-parametric-summed-density_files/figure-html/plot_individual_with_hpd-1.png" width="100%"></p>
</div>
<div class="section level5">
<h5 id="number-of-clusters">Number of Clusters<a class="anchor" aria-label="anchor" href="#number-of-clusters"></a>
</h5>
<p>The output data also contains information about the cluster
allocation of each sampled object, which we can use to build the
probability for there being a given number of total clusters. If we
believe the underlying individual clusters in the model have inherent
meaning in terms of representing genuine and distinct periods of site
usage, as opposed to simply providing a tool to enable a non-parametric
density estimate, this information may be archaeologically useful.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/PlotNumberOfClusters.html">PlotNumberOfClusters</a></span><span class="op">(</span>output_data <span class="op">=</span> <span class="va">polya_urn_output</span><span class="op">)</span></span></code></pre></div>
<p><img src="Non-parametric-summed-density_files/figure-html/plot_clusters-1.png" width="50%"></p>
</div>
</div>
<div class="section level3">
<h3 id="changing-the-calendar-age-plotting-scale">Changing the calendar age plotting scale<a class="anchor" aria-label="anchor" href="#changing-the-calendar-age-plotting-scale"></a>
</h3>
<p>For those plotting functions which present calendar ages (i.e.,
<code><a href="../reference/PlotCalendarAgeDensityIndividualSample.html">PlotCalendarAgeDensityIndividualSample()</a></code> and
<code><a href="../reference/PlotPredictiveCalendarAgeDensity.html">PlotPredictiveCalendarAgeDensity()</a></code>) we can change the
calendar age scale shown on the x-axis. The default is to plot on the
<em>cal yr BP</em> scale (as in the examples above). To instead plot in
<em>cal AD</em>, set <code>plot_cal_age_scale = "AD"</code>; while for
<em>cal BC</em>, set <code>plot_cal_age_scale = "AD"</code>, e.g.,</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">densities</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/PlotPredictiveCalendarAgeDensity.html">PlotPredictiveCalendarAgeDensity</a></span><span class="op">(</span></span>
<span>  output_data <span class="op">=</span> <span class="va">polya_urn_output</span>,</span>
<span>  show_SPD <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  plot_cal_age_scale <span class="op">=</span> <span class="st">"AD"</span><span class="op">)</span></span></code></pre></div>
<p><img src="Non-parametric-summed-density_files/figure-html/plot_density_2_AD-1.png" width="100%"></p>
</div>
<div class="section level3">
<h3 id="when-not-to-use-this-bayesian-non-parametric-method">When not to use this Bayesian non-parametric method<a class="anchor" aria-label="anchor" href="#when-not-to-use-this-bayesian-non-parametric-method"></a>
</h3>
<p>The current implementation of our Bayesian non-parametric approach
<strong>only</strong> supports normally-distributed clusters as the
components in the overall calendar age mixture distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>.
While this still allows a great deal of flexibility in the modelling, as
many distributions can be well approximated by normals, there are
certain distributions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>
for which they will struggle. In particular, you cannot approximate a
uniform phase well with a mixture of normal distributions.</p>
<p>If the underlying shared calendar age density
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>
is close to a uniform phase, or a mixture of uniform phases, then the
current (normally-distributed cluster component) Bayesian non-parametric
method is unlikely to work optimally and provide reliable summaries. In
such cases, we advise use of <code><a href="../reference/PPcalibrate.html">PPcalibrate()</a></code>. This
alternative approach is ideally suited to such situations.</p>
<p>The inhomogeneous Poisson process/changepoint approach taken by
<code><a href="../reference/PPcalibrate.html">PPcalibrate()</a></code> implicitly assumes a shared underlying
calendar age model for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\theta)</annotation></semantics></math>
that consists precisely of an unknown mixture of uniform phases.
Implementing <code><a href="../reference/PPcalibrate.html">PPcalibrate()</a></code> and plotting the posterior rate
of the Poisson process (<a href="Poisson-process-modelling.html">see
vignette</a>) will provide an estimate of that shared calendar age
density.</p>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-heaton2021" class="csl-entry">
Heaton, Timothy J. 2022. <span>“<span class="nocase">Non-parametric
Calibration of Multiple Related Radiocarbon Determinations and their
Calendar Age Summarisation</span>.”</span> <em>Journal of the Royal
Statistical Society Series C: Applied Statistics</em> 71 (5): 1918–56.
<a href="https://doi.org/10.1111/rssc.12599" class="external-link">https://doi.org/10.1111/rssc.12599</a>.
</div>
<div id="ref-miyake2012" class="csl-entry">
Miyake, Fusa, Kentaro Nagaya, Kimiaki Masuda, and Toshio Nakamura. 2012.
<span>“<span class="nocase">A signature of cosmic-ray increase in AD
774–775 from tree rings in Japan</span>.”</span> <em>Nature</em> 486
(7402): 240–42. <a href="https://doi.org/10.1038/nature11123" class="external-link">https://doi.org/10.1038/nature11123</a>.
</div>
<div id="ref-neal2000" class="csl-entry">
Neal, Radford M. 2000. <span>“Markov Chain Sampling Methods for
Dirichlet Process Mixture Models.”</span> <em>Journal of Computational
and Graphical Statistics</em> 9 (2): 249. <a href="https://doi.org/10.2307/1390653" class="external-link">https://doi.org/10.2307/1390653</a>.
</div>
<div id="ref-walker2007" class="csl-entry">
Walker, Stephen G. 2007. <span>“Sampling the Dirichlet Mixture Model
with Slices.”</span> <em>Communications in Statistics - Simulation and
Computation</em> 36 (1): 45–54. <a href="https://doi.org/10.1080/03610910601096262" class="external-link">https://doi.org/10.1080/03610910601096262</a>.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Timothy J Heaton, Sara Al-assam.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
