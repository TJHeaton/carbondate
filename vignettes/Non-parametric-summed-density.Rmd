---
title: "Non-parametric Summed Density"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Non-parametric Summed Density}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(carbondate)
set.seed(5)
```

# Non-parametric calibration of multiple related samples

## Model details

We model our unknown calendar age density $f(\theta)$ as an infinite mixture of individual clusters. These individual calendar age clusters are normal densities that can have different locations and spreads. In some cases, this mix of normal densities may represent true and distinct underlying normal archaeological phases, in which case additional practical inference may be possible. However this is not required for the method to provide good estimation. Each object is then considered to be drawn from one of the (infinite) clusters which constitute the overall $f(\theta)$. The probability that it is drawn from a particular cluster will depend upon the relative weight given to that specific cluster. It will be more likely than an object will come from some clusters than others. Given an object belongs to a particular cluster, its prior calendar age will be normally distributed with the mean and variance of that cluster. The mean and variance of each individual normal cluster that constitutes the overall $f(\theta)$, together with the weightings associated to each cluster, will be estimated based upon the set of ^14^C determinations we observe.

For full technical details of the models used, and explanation of the model parameters, see [@heaton2021].

## Run the sampler

Updating is performed within an overall Gibbs MCMC scheme by sampling the model parameters. There are two different schemes provided to update the DPMM --- a Polya Urn approach [@neal2000] which integrates out the mixing weights of each cluster; and a slice sampling approach in which they are explicitly retained [@walker2007].

Run using the Poly Urn method:

```{r calculate_walker, results=FALSE}
polya_urn_output <- PolyaUrnBivarDirichlet(
  rc_determinations = kerr$c14_age,
  rc_sigmas = kerr$c14_sig,
  calibration_curve=intcal20,
  n_iter = 1e4,
  n_thin = 5)
```

or the Walker method as follows:

```{r calculate_neal, results=FALSE}
walker_output <- WalkerBivarDirichlet(
  rc_determinations = kerr$c14_age,
  rc_sigmas = kerr$c14_sig,
  calibration_curve = intcal20,
  n_iter = 1e4,
  n_thin = 5)
```

Note this example only runs for 10,000 iterations - this is to keep the run time short, but is not enough to lead to a converged results. We suggest running for at least 100,000 iterations to arrive at the converged results, which are shown in [@heaton2021].

Both of these methods will output a list containing the sampler outputs at every $n_{\textrm{thin}}$ iteration, with the values of the model parameters and the calendar ages.

## Post-processing

Our sampler provides three outputs of particular interest.

#### Calendar Ages

As described above, the output data includes the calendar age estimate for each ^14^C sample. We can use this to determine the posterior distribution of the calendar age for each sample. Note that the calendar age estimates use the joint information provided by all the ^14^C determinations (as opposed to solely the ^14^C determination of the single object that would be found using `CalibrateSingleDetermination`) on the understanding the calendar ages of the objects are related.

You can calculate and plot this using `PlotCalendarAgeDensityIndividualSample` - for example to calculate the posterior calendar age distribution for the 21st ^14^C determination:

```{r plot_individual, out.width="100%", fig.width=10, fig.height=8}
PlotCalendarAgeDensityIndividualSample(21, polya_urn_output)
```

The highest posterior density range for a given probability and the unmodelled density (i.e. the result of `CalibrateSingleDetermination`) can also be shown on the plot by specifying this in the arguments, as shown below.

```{r plot_individual_with_hpd, out.width="100%", fig.width=10, fig.height=8}
PlotCalendarAgeDensityIndividualSample(
  21, polya_urn_output, show_hpd_ranges = TRUE, show_unmodelled_density = TRUE)
```

#### Density Estimate to Summarise Objects

The output data contains information to allow calculation of the predictive distribution for the calendar age of a new, as yet undiscovered, object. This density estimate summarises the calendar ages of all objects. It is generated using the posterior sampled values of the DPMM component of our MCMC sampler. This calendar age density can be calculated and plotted using `PlotPredictiveCalendarAgeDensity`.

The function allows calculation using multiple outputs so that their results can be compared. For example below we compare the results from the two sampler methods above.

```{r plot_density, out.width="100%", fig.width=10, fig.height=8}
densities <- PlotPredictiveCalendarAgeDensity(
  output_data = list(walker_output, polya_urn_output),
  n_posterior_samples = 500,
  denscale = 2.5)
```

We also have the option to plot the SPD, plot in the F^14^C scale and change the confidence intervals on the plot.

```{r plot_density_2, out.width="100%", fig.width=10, fig.height=8}
densities <- PlotPredictiveCalendarAgeDensity(
  output_data = polya_urn_output,
  n_posterior_samples = 500,
  denscale = 2.5,
  show_SPD = TRUE,
  interval_width = "bespoke",
  bespoke_probability = 0.8,
  plot_14C_age = FALSE)
```

#### Number of Clusters

The output data also contains information about the cluster allocation of each sampled object, which we can use to build the probability for there being a given number of total clusters. If we believe the underlying individual clusters in the model have inherent meaning in terms of representing genuine and distinct periods of site usage, as opposed to simply providing a tool to enable a non-parametric density estimate, this information may be archaeologically useful.

```{r plot_clusters, out.width="50%", fig.width=5, fig.height=6}
PlotNumberOfClusters(output_data = polya_urn_output)
```

# References
