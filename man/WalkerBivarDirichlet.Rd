% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/WalkerBivarDirichlet.R
\name{WalkerBivarDirichlet}
\alias{WalkerBivarDirichlet}
\title{Calibration of a set of individual radiocarbon samples using Walker updating
of the DPMM}
\usage{
WalkerBivarDirichlet(
  c14_determinations,
  c14_uncertainties,
  calibration_curve,
  lambda,
  nu1,
  nu2,
  A,
  B,
  alpha_shape,
  alpha_rate,
  n_iter = 100,
  n_thin = 10,
  calendar_ages = NA,
  slice_width = 1000,
  slice_multiplier = 10,
  n_clust = 10,
  sensible_initialisation = TRUE,
  show_progress = TRUE
)
}
\arguments{
\item{c14_determinations}{A vector containing the radiocarbon determinations.}

\item{c14_uncertainties}{A vector containing the radiocarbon determination
uncertainties. Must be the same length as \code{c14_determinations}.}

\item{calibration_curve}{A dataframe which should contain one column entitled
c14_age and one column entitled c14_sig.
This format matches \link{intcal20}.}

\item{lambda, nu1, nu2}{Hyperparameters for the prior on the means
\eqn{\phi_j} and precision \eqn{\tau_j} of each individual calendar age
cluster \eqn{j}.
\deqn{(\phi_j, \tau_j)|\mu_{\phi} \sim
\textrm{NormalGamma}(\mu_{\phi}, \lambda, \nu_1, \nu_2)} where
\eqn{\mu_{\phi}} is the overall cluster centering.}

\item{A, B}{Prior on \eqn{\mu_{\phi}} giving the mean and precision of the
overall centering \eqn{\mu_{\phi} \sim N(A, B^{-1})} i.e.
B small is uninformative.}

\item{alpha_shape, alpha_rate}{Hyperparameters for the shape and rate on prior
for DP concentration, \eqn{\alpha}, determining the number of clusters we
expect to observe among our n sampled objects.
\eqn{\alpha \sim \Gamma(\eta_1, \eta_2)} where \eqn{\eta_1, \eta_2} are
the \code{alpha_shape} and \code{alpha_rate}. A small alpha means more concentrated
(i.e. few clusters) while a large alpha means not concentrated (i.e. many
clusters).}

\item{n_iter}{The number of MCMC iterations (optional). Default is 100.}

\item{n_thin}{How much to thin the output (optional). 1 is no thinning,
a larger number is more thinning. Default is 10. Must choose an integer more
than 1 and not too close to \code{n_iter}, since after burn-in there are
\eqn{(n_{\textrm{iter}}/n_{\textrm{thin}})/2} samples from posterior to
potentially use.}

\item{calendar_ages}{The initial estimate for the underlying calendar ages
(optional). If supplied it must be a vector with the same length as
\code{c14_determinations}. Will be overridden if \code{sensible_initialisation} is
\code{TRUE}.}

\item{slice_width}{Parameter for slice sampling (optional). Default is 1000.}

\item{slice_multiplier}{Integer parameter for slice sampling (optional).
Default is 10. Limits the slice size to \code{slice_multiplier * slice_width}.}

\item{n_clust}{The initial number of clusters (optional). Default is 10.}

\item{sensible_initialisation}{Whether to use sensible start values and
adaptive prior on \eqn{\mu_{\phi}} and  (A, B).
If this is \code{TRUE} (the default), then \code{calendar_ages}, \code{A} and \code{B} will be
overridden from any values passed in the arguments.}

\item{show_progress}{Whether to show a progress bar in the console during
execution. Default is \code{TRUE}.}
}
\value{
A list with 12 items. The first 8 items contain output data, each of
which have one dimension of size \eqn{n_{\textrm{out}} =
\textrm{floor}( n_{\textrm{iter}}/n_{\textrm{thin}}) + 1}, each row storing
the result from every \eqn{n_{\textrm{thin}}}th iteration:

\describe{
\item{\code{cluster_identifiers}}{An \eqn{n_{\textrm{out}}} by
\eqn{n_{\textrm{obs}}} integer matrix. Gives the cluster allocation
- an integer between 1 and n_clust - for each observation.}
\item{\code{alpha}}{A double vector of length \eqn{n_{\textrm{out}}} giving the DP
concentration parameter.}
\item{\code{n_clust}}{An integer vector of length \eqn{n_{\textrm{out}}} giving
the number of clusters.}
\item{\code{phi}}{A list of length \eqn{n_{\textrm{out}}} each entry giving
a vector [of length nclust???] of the cluster means \eqn{\phi_j}.}
\item{\code{tau}}{A list of length \eqn{n_{\textrm{out}}} each entry giving
a vector [of length nclust???] of the cluster uncertainties \eqn{\tau_j}.}
\item{\code{weight}}{A list of length \eqn{n_{\textrm{out}}} each entry giving
the mixing weights of each cluster.}
\item{\code{calendar_ages}}{An \eqn{n_{\textrm{out}}} by \eqn{n_{\textrm{obs}}}
integer matrix. Gives the calendar age for each observation.}
\item{\code{mu_phi}}{A vector of length \eqn{n_{\textrm{out}}} giving the overall
centering \eqn{\mu_{\phi}} of the clusters.}
}
where \eqn{n_{\textrm{obs}}} is the number of radiocarbon observations i.e.
the length of \code{c14_determinations}.

The remaining 4 items contain information that is used for later
post-processing of the output data:

\describe{
\item{\code{update_type}}{A string that always has the value "neal"}
\item{\code{lambda}}{The fixed hypeparameter lambda.}
\item{\code{nu1}}{The fixed hypeparameter nu1}
\item{\code{nu2}}{The fixed hypeparameter nu2}
}
}
\description{
This function takes as an input a set of radiocarbon determinations and
associated 1-sigma uncertainties, as well as the calibration curve which
should be used, and returns output data that can be sampled to estimate the
joint calendar age density and cluster.
}
\details{
In this method slice sampling is used to update the DPMM.
[TODO Do we want to include more detail about the algorith
here? Or refer to the paper.]
}
\examples{
# Basic usage making use of sensible initialisation to set most values
WalkerBivarDirichlet(
  c14_determinations = c(602, 805, 1554),
  c14_uncertainties = c(35, 34, 45),
  calibration_curve = intcal20,
  lambda = 0.1,
  nu1 = 0.25,
  nu2 = 10,
  alpha_shape = 1,
  alpha_rate = 1)
}
